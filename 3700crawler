#!/usr/bin/env python3

import sys, select, argparse, socket, ssl, zlib, gzip
from html.parser import HTMLParser

# CONSTANTS
DEFAULT_SERVER = "proj5.3700.network"
DEFAULT_PORT = 443
RETRY_LIMIT = 10

# STATUS CODES
OK = 'HTTP/1.1 200 OK'
BAD_REQUEST = 'HTTP/1.1 400 Bad Request'
FOUND = 'HTTP/1.1 302 Found'
FORBIDDEN = 'HTTP/1.1 403 Forbidden'
NOT_FOUND = 'HTTP/1.1 404 Not Found'
SERVICE_UNAVAILABLE = 'HTTP/1.1 503 Service Unavailable'


class Crawler:
    
    # Currently only handles one URL and response at a time
    def __init__(self, args):
        self.server = args.server
        self.port = args.port
        self.username = args.username
        self.password = args.password

        self.secure_socket = None
        self.visited = ['/accounts/logout/']
        self.frontier = []
        self.flags = []

        self.sessionID = ''
        self.csrftoken = ''
        self.csrfmiddlewaretoken = ''

        self.current_url = ''
        self.current_status = ''
        self.current_headers = {}
        self.current_body = ''

        self.retry_counter = 0
    
    # OPEN AND CONNECT OVER TLS TCP SOCKET
    def open_secure_socket(self):
        # CREATE SOCKET 
        mysocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # WRAP SOCKET 
        SSL_CONTEXT = ssl.create_default_context()
        secure_socket = SSL_CONTEXT.wrap_socket(mysocket, server_hostname=self.server)
        secure_socket.settimeout(3)

        # SET AS CRAWLER SOCKET
        self.secure_socket = secure_socket

        # CONNECT 
        self.secure_socket.connect((self.server, self.port))

    # SEND GET REQUEST 
    def send_get_request(self, url):
        if not isinstance(url, str):
            sys.exit(f'TypeError: send_get_request expects a string, not {type(url)}')

        self.current_url = url
        self.visited += self.current_url,

        request = f"GET {self.current_url} HTTP/1.1\r\nHost: {self.server}\r\naccept-encoding: gzip\r\ncookie: csrftoken={self.csrftoken}; sessionid={self.sessionID}\r\n\r\n"
        
        print("Request to %s:%d\n" % (self.server, self.port))
        print(request)

        self.secure_socket.send(request.encode('ascii'))
        self.receive_headers()

    # SEND POST REQUEST (expects fields as a dict)
    def send_post_request(self, path, fields):
        if not isinstance(path, str):
            sys.exit(f'TypeError: send_post_request expects a string for path, not {type(path)}')
        if not isinstance(fields, dict):
            sys.exit(f'TypeError: send_post_request expects a dict for fields, not {type(fields)}')

        body = ''

        for k in fields:
            body += (k + '=' + fields[k] + '&') 
        body = body[:-1] + '\r\n\r\n'

        content_length = len(body.encode('ascii'))

        request =  f"POST {path} HTTP/1.1\r\nHost: {self.server}\r\naccept-encoding: gzip\r\ncontent-length: {content_length}\r\ncontent-type: application/x-www-form-urlencoded\r\ncookie: csrftoken={self.csrftoken}; sessionid={self.sessionID}\r\n\r\n" + body

        print("Request to %s:%d\n" % (self.server, self.port))
        print(request)

        self.secure_socket.send(request.encode('ascii'))
        return self.receive_headers()

    # LOG INTO FAKEBOOK
    def log_in(self):
        self.send_get_request('/accounts/login/')
        self.send_post_request(
            '/accounts/login/', 
            {'username':self.username, 
            'password':self.password,
            'csrfmiddlewaretoken':self.csrfmiddlewaretoken,
            'next':''})

    def receive_headers(self):
        print("RECEIVING...\n")
        
        buf_size = 1024
        response = ''
        data = b''

        # RECEIVE HEADERS
        while not b'\r\n\r\n' in data:
            try:
                data = self.secure_socket.recv(buf_size)
                if data.startswith(b'\x1f'):
                    self.current_body = data
                else:
                    print(data)
                    # Only get the headers
                    data_split = data.split(b'\r\n\r\n')
                    headers = data_split[0]
                    # If some of the body was received, store it for later
                    if len(data_split) == 2:
                        body_segment = data_split[1]
                        self.current_body = body_segment
                    
                    response += headers.decode('ascii')
            except socket.error:
                print("ERROR READING HEADER: " + str(socket.error))
                exit()
        print("HEADERS RECEIVED.\n")

        # SET HEADERS
        self.handle_response_headers(response)

        # HANDLE STATUS
        self.handle_status()

    # Receive and handle the body
    def receive_body(self, buf_size):
        print(f"RECEIVING BUFFER SIZE: {buf_size} ...\n")
        
        response = ''

        # If some of the body has already been read (gzip header) add it to data
        data = self.current_body

        # Receive the rest of the body
        data += self.secure_socket.recv(buf_size)
        decomp_data = gzip.decompress(data)
        response += decomp_data.decode('ascii')

        print("RECEIVED BODY.\n")

        print("SETTING BODY TO: ")
        print(response)

        # SET BODY
        self.current_body = response 

    def handle_response_headers(self, response):
        headers = response.split('\r\n\n\n')[0].split('\r\n')
        self.current_status = headers[0]
        self.set_headers(headers)

    def handle_status(self):
        if self.current_status == BAD_REQUEST:
            print("BAD REQUEST")
            self.handle_BAD_REQUEST()

        elif self.current_status == OK:
            print("OK")
            self.handle_OK()
            
        elif self.current_status == FOUND:
            print("FOUND")
            self.handle_FOUND()

        elif self.current_status in (FORBIDDEN, NOT_FOUND):
            print("BAD URL")
            self.handle_BAD_URL()

        elif self.current_status == SERVICE_UNAVAILABLE:
            print("SERVICE UNAVAILABLE")
            self.handle_SERVICE_UNAVAILABLE()

    # TODO print some error
    def handle_BAD_REQUEST(self):
        print('HTTP/1.1 400 Bad Request', file=sys.stderr)
        exit()

    def handle_OK(self):
        self.receive_body(int(self.current_headers['Content-Length']))

        self.retry_counter = 0
        self.parse_html()

        if 'sessionid' in self.current_headers['Cookies'].keys():
            self.sessionID = self.current_headers['Cookies']['sessionid']
        if 'csrftoken' in self.current_headers['Cookies'].keys():
            self.csrftoken = self.current_headers['Cookies']['csrftoken']

    def handle_FOUND(self):
        self.receive_body(int(self.current_headers['Content-Length']))

        # try request again with new URL in Location header (continue parsing)
        if 'sessionid' in self.current_headers['Cookies'].keys():
            self.sessionID = self.current_headers['Cookies']['sessionid']
        if 'csrftoken' in self.current_headers['Cookies'].keys():
            self.csrftoken = self.current_headers['Cookies']['csrftoken']
        location = self.current_headers['Location']
        
        # TODO: this is a quick fix 
        if location in self.frontier: 
            self.frontier.remove(location)

        self.send_get_request(location)

    def handle_BAD_URL(self):
        # abandon the URL that generated the response code (never visit again)
        print()

    def handle_SERVICE_UNAVAILABLE(self):
        # retry request for the URL until successful (store a current URL? pass URL?)
        print("SERVICE UNAVAILABLE ... RETRYING\n*\n*\n*\n*\n*")
        
        if self.retry_counter < RETRY_LIMIT:
            self.receive_headers(self)
            self.retry_counter += 1

    def set_headers(self, headers):
        self.current_headers['Cookies'] = {}
        for h in headers:
            # current_reponse needs unique keys, so store each 'Set-Cookie' header in 
            # a 'Cookies' dictionary 
            if 'Set-Cookie: ' in h:
                # Isolate cookie value in 'Set-Cookie: ' header
                cookie = h.replace('Set-Cookie: ','')
                # Desired cookie value is bounded by '<cookie_type>=' and '; <attributes>'
                # so split by ';' to isolate '<cookie_type>=<cookie_value>' 
                # then split by '=' to get pair ['<cookie_type>','<cookie_value>']
                pair = cookie.split(';')[0].split('=')
                # Set the cookie key and value in the cookies dictionary in current_headers 
                self.current_headers['Cookies'][pair[0]] = pair[1]
            elif ':' in h:
                # Split each header => Header: value --> ['Header','value']
                pair = h.split(': ')
                # Set current_response header key and associated value from pair above
                self.current_headers[pair[0]] = pair[1]

    def parse_html(self):
        parser = MyHTMLParser()
        parser.feed(self.current_body)
        if parser.data['csrf']:
            self.csrfmiddlewaretoken = parser.data['csrf']
        if parser.data['flags']:
            for f in parser.data['flags']:
                if f not in self.flags:
                    self.flags += f,
        if parser.data['urls']:
            for u in parser.data['urls']:
                u = self.truncate_target(u)
                if (u not in self.visited) and (u not in self.frontier) and (len(u) > 0):
                    print("ADD TO FRONTIER ::::: " + u)
                    self.frontier.append(u)

    def truncate_target(self, url):
        if url.startswith('/'):
            return url
        elif url.startswith('https://proj5.3700.network/'):
            return url.replace('https://proj5.3700.network','')
        else:
            return ''

    def run(self):
        self.open_secure_socket()
        self.log_in()
       
        while (len(self.frontier) > 0) or (len(self.flags) != 5) :
            next = self.frontier.pop(0)
            if next in self.visited:
                print("####### IN VISITED #######")
                print(next)
                exit()

            self.send_get_request(next)
            
            if len(set(self.visited)) != len(self.visited):
                print("####### DUPLICATES #######")
                exit()
            print("VISITED: " + str(len(self.visited)))
            print("FLAGS: " + str(self.flags))

        print("--------------- Metrics ------------------")
        print(self.visited)
        print('Number of pages visited: ' + str(len(self.visited)))
        print('\nFlags: ')
        print(self.flags)
        print("-----------------------------------------")
        

class MyHTMLParser(HTMLParser):
    def __init__(self):
        HTMLParser.__init__(self)
        self.data = {
            'csrf':'',
            'urls':[],
            'flags':[]
        }

    def handle_starttag(self, tag, attrs):
        if tag == 'input':
            tag_dict = dict(attrs)
            if 'csrfmiddlewaretoken' in tag_dict.values():
                self.data['csrf'] = tag_dict['value']
        
        if tag == 'a':
            tag_dict = dict(attrs)
            if 'href' in tag_dict.keys():
                self.data['urls'] += tag_dict['href'],

    def handle_data(self, data):
        if data.startswith('FLAG: '):
            self.data['flags'] += data.replace('FLAG: ',''),

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='crawl Fakebook')
    parser.add_argument('-s', dest="server", type=str, default=DEFAULT_SERVER, help="The server to crawl")
    parser.add_argument('-p', dest="port", type=int, default=DEFAULT_PORT, help="The port to use")
    parser.add_argument('username', type=str, help="The username to use")
    parser.add_argument('password', type=str, help="The password to use")
    args = parser.parse_args()
    sender = Crawler(args)
    sender.run()
